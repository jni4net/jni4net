#region Copyright (C) 2009 by Pavel Savara
/*
This file is part of tools for jni4net - bridge between Java and .NET
http://jni4net.sourceforge.net/

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using java.lang;
using java.lang.reflect;
using Microsoft.CSharp;
using net.sf.jni4net.attributes;
using net.sf.jni4net.jni;
using net.sf.jni4net.proxygen.config;
using net.sf.jni4net.utils;
using Object=java.lang.Object;
using StringBuilder=System.Text.StringBuilder;

namespace net.sf.jni4net.proxygen
{
    internal partial class Generator
    {
        #region Nested type: Java2Net

        private class Java2Net
        {
            private Generator generator;
            private IList<SkipMethod> skipMethods;

            public Java2Net(IList<SkipMethod> skipMethods, Generator generator)
            {
                this.skipMethods = skipMethods;
                this.generator = generator;
            }

            public void Generate(Class clazz, string directory)
            {
                string dir = Path.Combine(directory, clazz.PackageName.Replace('.', '/'));
                if (!Directory.Exists(dir))
                {
                    Directory.CreateDirectory(dir);
                }
                string fileName = Path.Combine(directory, clazz.FullName.Replace('.', '/') + ".generated.cs");
                using (var sw = new StreamWriter(fileName))
                {
                    var sb = new StringBuilder();
                    var stringWriter = new StringWriter(sb);

                    var cscProvider = new CSharpCodeProvider();

                    var cop = new CodeGeneratorOptions();

                    var unit = new CodeCompileUnit();
                    {
                        var nmsp = new CodeNamespace(clazz.PackageName);
                        {
                            Generate(clazz, nmsp);
                        }
                        unit.Namespaces.Add(nmsp);
                    }

                    cscProvider.GenerateCodeFromCompileUnit(unit, stringWriter, cop);
                    stringWriter.Close();

                    sb.Replace("This code was generated by a tool.",
                                     "This code was generated by jni4net. See http://jni4net.sourceforge.net/ ");
                    sw.Write(sb);

                }
            }

            private void Generate(Class clazz, CodeNamespace nmsp)
            {
                Method[] methods;
                if (clazz == Throwable._class)
                {
                    methods = clazz.getMethods();
                }
                else
                {
                    methods = clazz.getDeclaredMethods();
                }
                bool isProxy = clazz.isInterface();
                if (isProxy)
                {
                    nmsp.Types.Add(CreateInterface(clazz, null, methods));
                    nmsp.Types.Add(CreateInterfaceHelper(clazz));
                }
                Class superclass = clazz.getSuperclass();
                if (isProxy)
                {
                    superclass = Object._class;
                }
                if (clazz.FullName == "java.lang.Throwable")
                {
                    superclass = null;
                }
                CodeTypeReference baseClass = superclass == null
                                                  ? null
                                                  : generator.ResolveClassReference(superclass);
                nmsp.Types.Add(CreateClass(clazz, baseClass, methods, isProxy));
            }

            private CodeTypeDeclaration CreateInterface(Class clazz, CodeTypeReference baseClass, Method[] methods)
            {
                CodeTypeDeclaration iface;
                iface = new CodeTypeDeclaration(clazz.ShortName);
                iface.CustomAttributes.Add(
                    new CodeAttributeDeclaration(new CodeTypeReference(typeof (JavaInterfaceAttribute),
                                                                       CodeTypeReferenceOptions.GlobalReference)));
                //iface.StartDirectives.Add(new CodeRegionDirective(CodeRegionMode.Start, "interface " + iface.Name));
                iface.StartDirectives.Add(new CodeRegionDirective(CodeRegionMode.Start, cdc));
                iface.EndDirectives.Add(new CodeRegionDirective(CodeRegionMode.End, cdc));
                //iface.EndDirectives.Add(new CodeRegionDirective(CodeRegionMode.End, "interface " + iface.Name));
                if (baseClass != null)
                {
                    iface.BaseTypes.Add(baseClass);
                }
                //iface.BaseTypes.Add(new CodeTypeReference(typeof (IJavaProxy), CodeTypeReferenceOptions.GlobalReference));
                iface.TypeAttributes = TypeAttributes.Public;
                iface.IsInterface = true;
                iface.IsPartial = true;
                for (int m = 0; m < methods.Length; m++)
                {
                    CreateMethod(clazz, iface, m, methods[m], null, true, true, null, false);
                }
                return iface;
            }

            private CodeTypeDeclaration CreateInterfaceHelper(Class clazz)
            {
                CodeTypeDeclaration helper;
                helper = new CodeTypeDeclaration(clazz.ShortName+"_");
                helper.StartDirectives.Add(new CodeRegionDirective(CodeRegionMode.Start, cdc));
                helper.EndDirectives.Add(new CodeRegionDirective(CodeRegionMode.End, cdc));
                helper.TypeAttributes = TypeAttributes.Public;
                helper.IsPartial = true;

                var claprop = new CodeMemberProperty();
                claprop.Type = new CodeTypeReference(typeof(Class));
                claprop.Name = "_class";
                claprop.GetStatements.Add(
                    new CodeMethodReturnStatement(
                        new CodeFieldReferenceExpression(
                            new CodeTypeReferenceExpression(CreateClassReference(clazz, true)), "_class")));
                helper.Members.Add(claprop);
                claprop.Attributes = MemberAttributes.Static | MemberAttributes.Public | MemberAttributes.New;
                
                return helper;
            }

            private CodeTypeDeclaration CreateClass(Class clazz, CodeTypeReference baseClass, Method[] methods,
                                                    bool isProxy)
            {
                var type = new CodeTypeDeclaration();
                bool isSealedClass = false;
                if (baseClass != null)
                {
                    type.BaseTypes.Add(baseClass);
                }
                if (isProxy)
                {
                    type.Name = "__" + clazz.ShortName;
                    type.CustomAttributes.Add(
                        new CodeAttributeDeclaration(new CodeTypeReference(typeof (JavaProxyAttribute),
                                                                           CodeTypeReferenceOptions.GlobalReference)));
                    type.BaseTypes.Add(CreateClassReference(clazz, false));
                    type.TypeAttributes = TypeAttributes.NotPublic;
                }
                else
                {
                    type.Name = clazz.ShortName;
                    type.CustomAttributes.Add(
                        new CodeAttributeDeclaration(new CodeTypeReference(typeof (JavaClassAttribute),
                                                                           CodeTypeReferenceOptions.GlobalReference)));
                    type.TypeAttributes = TypeAttributes.Public;
                    var classModifiers = (ModifierFlags) clazz.getModifiers();
                    /*if ((classModifiers & (Modifier.Abstract | Modifier.Interface)) == Modifier.Abstract)
                    {
                        type.TypeAttributes |= TypeAttributes.Abstract;
                    }*/
                    if ((classModifiers & (ModifierFlags.Final)) == ModifierFlags.Final)
                    {
                        type.TypeAttributes |= TypeAttributes.Sealed;
                        isSealedClass = true;
                    }
                }
                //type.StartDirectives.Add(new CodeRegionDirective(CodeRegionMode.Start, "class " + type.Name));
                type.StartDirectives.Add(new CodeRegionDirective(CodeRegionMode.Start, cdc));
                type.EndDirectives.Add(new CodeRegionDirective(CodeRegionMode.End, cdc));
                //type.EndDirectives.Add(new CodeRegionDirective(CodeRegionMode.End, "class " + type.Name));
                //TODO type.CustomAttributes.Add(new CodeAttributeDeclaration(new CodeTypeReference(typeof (DebuggerStepThroughAttribute), CodeTypeReferenceOption)));
                type.IsPartial = true;
                type.IsClass = true;

                #region Base classes

                foreach (Class ifc in clazz.getInterfaces())
                {
                    if (ifc.getName() != "system.IObject")
                    {
                        type.BaseTypes.Add(generator.ResolveClassReference(ifc));
                    }
                }

                #endregion

                #region class static

                var staticfield =
                    new CodeMemberField(
                        new CodeTypeReference(typeof (Class) /*, CodeTypeReferenceOptions.GlobalReference*/),
                        "staticClass");
                staticfield.Attributes = MemberAttributes.Static | MemberAttributes.Private;
                type.Members.Add(staticfield);

                var claprop = new CodeMemberProperty();
                claprop.Type = new CodeTypeReference(typeof (Class) /*, CodeTypeReferenceOptions.GlobalReference*/);
                claprop.Name = "_class";
                claprop.GetStatements.Add(
                    new CodeMethodReturnStatement(
                        new CodeFieldReferenceExpression(
                            new CodeTypeReferenceExpression(CreateClassReference(clazz, isProxy)), "staticClass")));
                type.Members.Add(claprop);
                claprop.Attributes = MemberAttributes.Static | MemberAttributes.Public | MemberAttributes.New;

                var init = new CodeMemberMethod();
                init.Name = "InitJNI";
                init.Attributes |= MemberAttributes.Static;
                var jniEnv = new CodeTypeReference(typeof (JNIEnv), CodeTypeReferenceOptions.GlobalReference);
                var statClass = new CodeTypeReference(typeof (Class));
                init.Parameters.Add(new CodeParameterDeclarationExpression(jniEnv, "env"));
                init.Parameters.Add(new CodeParameterDeclarationExpression(statClass, "staticClass"));
                init.Statements.Add(
                    new CodeAssignStatement(
                        new CodeFieldReferenceExpression(
                            new CodeTypeReferenceExpression(CreateClassReference(clazz, isProxy)), "staticClass"),
                        new CodeVariableReferenceExpression("staticClass")));

                type.Members.Add(init);

                #endregion

                #region construction helper

                var constructionHelper = new CodeTypeDeclaration("ContructionHelper");
                constructionHelper.BaseTypes.Add(new CodeTypeReference(typeof (IConstructionHelper),
                                                                       CodeTypeReferenceOptions.GlobalReference));
                var createMethod = new CodeMemberMethod();
                createMethod.ReturnType = new CodeTypeReference(typeof(IJavaProxy), CodeTypeReferenceOptions.GlobalReference);
                createMethod.Parameters.Add(
                    new CodeParameterDeclarationExpression(
                        new CodeTypeReference(typeof (JNIEnv), CodeTypeReferenceOptions.GlobalReference), "env"));

                createMethod.Statements.Add(
                    new CodeMethodReturnStatement(new CodeObjectCreateExpression(CreateClassReference(clazz, isProxy),
                                                                                 new CodeVariableReferenceExpression(
                                                                                     "env"))));
                createMethod.Name = "CreateProxy";
                createMethod.Attributes = MemberAttributes.Public|MemberAttributes.Final;
                constructionHelper.Members.Add(createMethod);
                constructionHelper.TypeAttributes = TypeAttributes.NotPublic|TypeAttributes.Sealed;
                type.Members.Add(constructionHelper);
                
                #endregion

                int c = 0;
                for (int m = 0; m < methods.Length; m++)
                {
                    Method method = methods[m];
                    if (!method.IsAnnotationPresent("net.sf.jni4net.attributes.NetMethod"))
                    {
                        CreateMethod(clazz, type, c++, method, init.Statements, isProxy, false, null, isSealedClass);
                    }
                }
                foreach (Field field in clazz.getFields())
                {
                    CreateField(type, clazz, c++, isProxy, field, init.Statements);
                }
                foreach (Class ifc in clazz.getInterfaces())
                {
                    if (ifc.getName() != "system.IObject")
                    {
                        Method[] methods2 = ifc.getMethods();
                        for (int m = 0; m < methods2.Length; m++)
                        {
                            CreateMethod(clazz, type, c++, methods2[m], init.Statements, isProxy, false,
                                         generator.ResolveClassReference(ifc), isSealedClass);
                        }
                    }
                }
                bool isNetClass = clazz.IsAnnotationPresent("net.sf.jni4net.attributes.NetClass");
                if (!isProxy)
                {
                    Constructor[] constructors = clazz.getConstructors();
                    foreach (Constructor constructor in constructors)
                    {
                        CreateConstructor(clazz, type, c++, constructor, init.Statements, isSealedClass);
                    }
                    if (constructors.Length == 0)
                    {
                        var cc = new CodeConstructor();
                        cc.Attributes = MemberAttributes.Family;
                        cc.BaseConstructorArgs.Add(
                            new CodeCastExpression(
                                new CodeTypeReference(typeof (JNIEnv), CodeTypeReferenceOptions.GlobalReference),
                                new CodePrimitiveExpression(null)));
                        type.Members.Add(cc);
                    }
                }
                if (clazz.FullName != "java.lang.Object" && clazz.FullName != "java.lang.Throwable" && !isNetClass)
                {
                    CreateEnvConstructor(type,
                                         clazz.FullName == "java.lang.String" || clazz.FullName == "java.lang.Class");
                }
                return type;
            }

            private void CreateEnvConstructor(CodeTypeDeclaration type, bool pub)
            {
                var cc = new CodeConstructor();
                cc.Attributes = pub ? MemberAttributes.FamilyOrAssembly : MemberAttributes.Family;
                cc.Parameters.Add(
                    new CodeParameterDeclarationExpression(
                        new CodeTypeReference(typeof (JNIEnv), CodeTypeReferenceOptions.GlobalReference), "env"));
                cc.BaseConstructorArgs.Add(new CodeVariableReferenceExpression("env"));
                type.Members.Add(cc);
            }

            private void CreateConstructor(Class clazz, CodeTypeDeclaration type, int m, Constructor constructor,
                                           CodeStatementCollection init, bool isSealedClass)
            {
                var modifiers = (ModifierFlags) constructor.getModifiers();
                if ((modifiers & (ModifierFlags.Private | ModifierFlags.Synthetic)) != ModifierFlags.None)
                {
                    return;
                }

                string name = clazz.ShortName;
                string signature = constructor.GetSignature();
                IList<Class> parameterTypes = constructor.getParameterTypes();
                string uName = ("__ctor" + name + m).Replace('$', '_');
                var ignored = new SkipMethod(clazz.FullName, name, signature);
                if (skipMethods.Contains(ignored))
                {
                    return;
                }

                CodeConstructor con = CreateConstructorSignature(clazz, name, signature, parameterTypes, modifiers,
                                                                 isSealedClass);
                CreateMethodBody(name, signature, clazz, null, parameterTypes, con.Statements, init, uName, false, false,
                                 true, false);
                string className = clazz.getName();
                if (className != "java.lang.Object" && className != "java.lang.Throwable")
                {
                    con.BaseConstructorArgs.Add(
                        new CodeCastExpression(
                            new CodeTypeReference(typeof (JNIEnv), CodeTypeReferenceOptions.GlobalReference),
                            new CodePrimitiveExpression(null)));
                }

                type.Members.Add(con);

                var field =
                    new CodeMemberField(
                        new CodeTypeReference(typeof (MethodId), CodeTypeReferenceOptions.GlobalReference),
                        uName);
                field.Attributes = MemberAttributes.Static | MemberAttributes.Private;
                type.Members.Add(field);
            }

            private CodeConstructor CreateConstructorSignature(Class clazz, string name, string signature,
                                                               IList<Class> parameterTypes, ModifierFlags modifiers,
                                                               bool isSealedClass)
            {
                var con = new CodeConstructor();
                con.Name = name.Replace('$', '_');
                con.Attributes = 0;
                CreateModifiers(con, name, null, modifiers, clazz, signature, false, false, isSealedClass);
                CreateSignatureParams(con, parameterTypes);

                if (!generator.config.SkipSignatures)
                {
                    var declaration =
                        new CodeAttributeDeclaration(new CodeTypeReference(typeof (JavaMethodAttribute),
                                                                           CodeTypeReferenceOptions.GlobalReference));
                    CodeExpression expression = new CodePrimitiveExpression(signature);
                    declaration.Arguments.Add(new CodeAttributeArgument(expression));
                    con.CustomAttributes.Add(declaration);
                }

                return con;
            }

            private void CreateSignatureParams(CodeMemberMethod method, IList<Class> parameterTypes)
            {
                for (int p = 0; p < parameterTypes.Count; p++)
                {
                    Class paramType = parameterTypes[p];

                    var parameter = new CodeParameterDeclarationExpression();
                    parameter.Name = GetParamName(paramType, p);
                    parameter.Type = generator.ResolveClassReference(paramType);
                    method.Parameters.Add(parameter);
                }
            }


            private void CreateField(CodeTypeDeclaration type, Class clazz, int m, bool isProxy, Field field,
                                     CodeStatementCollection init)
            {
                var modifiers = (ModifierFlags) field.getModifiers();
                if ((modifiers & (ModifierFlags.Private | ModifierFlags.Synthetic)) != ModifierFlags.None)
                {
                    return;
                }

                string name = field.getName();
                string signature = field.GetSignature();
                string uName = ("__" + name + m).Replace('$', '_');
                bool isStatic = (modifiers & ModifierFlags.Static) == ModifierFlags.Static;

                var fieldProp = new CodeMemberProperty();
                Class returnType = field.getType();
                CodeTypeReference typeRef = generator.ResolveClassReference(returnType);
                fieldProp.Type = typeRef;
                fieldProp.Name = name;
                fieldProp.Attributes = 0;
                if (isStatic)
                {
                    fieldProp.Attributes |= MemberAttributes.Static;
                }
                if ((modifiers & ModifierFlags.Public) == ModifierFlags.Public)
                {
                    fieldProp.Attributes |= MemberAttributes.Public;
                }
                if ((modifiers & ModifierFlags.Protected) == ModifierFlags.Protected)
                {
                    fieldProp.Attributes |= MemberAttributes.Public;
                }
                if ((modifiers & ModifierFlags.Final) == ModifierFlags.Final)
                {
                    fieldProp.Attributes |= MemberAttributes.Final;
                }

                CreateMethodBody(name, signature, clazz, returnType, new Class[] {}, fieldProp.GetStatements, init,
                                 uName, isStatic, isProxy, false, true);
                type.Members.Add(fieldProp);

                var fieldId =
                    new CodeMemberField(
                        new CodeTypeReference(typeof (FieldId), CodeTypeReferenceOptions.GlobalReference),
                        uName);
                fieldId.Attributes = MemberAttributes.Static | MemberAttributes.Private;
                type.Members.Add(fieldId);
            }

            private void CreateMethod(Class clazz, CodeTypeDeclaration type, int m, Method method,
                                      CodeStatementCollection init,
                                      bool isProxy, bool isInterface, CodeTypeReference isInterfaceMethod,
                                      bool isSealedClass)
            {
                var modifiers = (ModifierFlags) method.getModifiers();
                if ((modifiers & (ModifierFlags.Private | ModifierFlags.Synthetic)) != ModifierFlags.None)
                {
                    return;
                }
                if (method.IsAnnotationPresent("net.sf.jni4net.attributes.NetMethod"))
                {
                    return;
                }
                string name = method.getName();
                string signature = method.GetSignature();
                var ignored = new SkipMethod(clazz.FullName, name, signature);
                if (skipMethods.Contains(ignored))
                {
                    return;
                }

                Class returnType = method.getReturnType();
                IList<Class> parameterTypes = method.getParameterTypes();
                string uName = ("__" + name + m).Replace('$', '_');
                bool isStatic = (modifiers & ModifierFlags.Static) == ModifierFlags.Static;

                CodeMemberMethod meth = CreateMethodSignature(clazz, name, signature, returnType, parameterTypes,
                                                              modifiers,
                                                              isProxy, isInterfaceMethod != null, isSealedClass);
                if (isInterfaceMethod != null)
                {
                    meth.PrivateImplementationType = isInterfaceMethod;
                }
                if (!isInterface)
                {
                    CreateMethodBody(name, signature, clazz, returnType, parameterTypes, meth.Statements, init, uName,
                                     isStatic, isProxy,
                                     false, false);
                }

                type.Members.Add(meth);

                var field =
                    new CodeMemberField(
                        new CodeTypeReference(typeof (MethodId), CodeTypeReferenceOptions.GlobalReference),
                        uName);
                field.Attributes = MemberAttributes.Static | MemberAttributes.Private;
                type.Members.Add(field);
            }

            private void CreateMethodBody(string name, string signature, Class clazz, Class returnType,
                                          IList<Class> parameterTypes, CodeStatementCollection statements,
                                          CodeStatementCollection init, string uName, bool isStatic,
                                          bool isProxy, bool isConstructor, bool isField)
            {
                CodeExpression claxs;
                var classReference = new CodeTypeReferenceExpression(CreateClassReference(clazz, isProxy));
                claxs = new CodeFieldReferenceExpression(classReference, "staticClass");
                string getmethodidthrow = isField
                                              ? isStatic ? "GetStaticFieldID" : "GetFieldID"
                                              : isStatic ? "GetStaticMethodID" : "GetMethodID";
                var initBody =
                    new CodeAssignStatement(
                        new CodeFieldReferenceExpression(
                            classReference, uName),
                        new CodeMethodInvokeExpression(
                            new CodeVariableReferenceExpression("env"), getmethodidthrow,
                            claxs,
                            new CodePrimitiveExpression(isConstructor ? "<init>" : name),
                            new CodePrimitiveExpression(signature)));
                init.Add(initBody);


                if (isStatic || isConstructor)
                {
                    CodeStatement statement =
                        new CodeVariableDeclarationStatement(
                            new CodeTypeReference(typeof (JNIEnv), CodeTypeReferenceOptions.GlobalReference), "env",
                            new CodeMethodInvokeExpression(
                                new CodeTypeReferenceExpression(
                                    new CodeTypeReference(typeof (JNIEnv), CodeTypeReferenceOptions.GlobalReference)),
                                "GetEnv"));
                    statements.Add(statement);
                }
                else
                {
                    CodeStatement statement =
                        new CodeVariableDeclarationStatement(
                            new CodeTypeReference(typeof (JNIEnv), CodeTypeReferenceOptions.GlobalReference), "env",
                            new CodePropertyReferenceExpression
                                (new CodeThisReferenceExpression
                                     (), "Env"));
                    statements.Add(statement);
                }


                var callName = new StringBuilder();
                if (isConstructor)
                {
                    callName.Append("NewObject");
                }
                else
                {
                    if (returnType != null && returnType.isPrimitive())
                    {
                        callName.Append(returnType.FullName);
                        callName[0] = Char.ToUpper(callName[0]);
                    }
                    else
                    {
                        callName.Append("Object");
                    }
                    if (isStatic)
                    {
                        callName.Insert(0, "Static");
                    }
                    callName.Insert(0, isField ? "Get" : "Call");
                    callName.Append(isField ? "Field" : "Method");
                }
                int offset = isConstructor ? 3 : 2;
                var expressions = new CodeExpression[parameterTypes.Count + offset];
                if (isStatic || isConstructor)
                {
                    expressions[0] =
                        new CodeFieldReferenceExpression(
                            classReference,
                            "staticClass");
                }
                else
                {
                    expressions[0] = new CodeThisReferenceExpression();
                }
                expressions[1] = new CodeFieldReferenceExpression(
                    classReference,
                    uName);
                if (isConstructor)
                {
                    expressions[2] = new CodeThisReferenceExpression();
                }
                for (int i = 0; i < parameterTypes.Count; i++)
                {
                    Class type = parameterTypes[i];
                    string paramName = GetParamName(type, i);
                    CodeExpression expression = new CodeVariableReferenceExpression(paramName);
                    if (type.isArray())
                    {
                        expressions[i + offset] =
                            new CodeMethodInvokeExpression(
                                new CodeTypeReferenceExpression(new CodeTypeReference(typeof (Value),
                                                                                      CodeTypeReferenceOptions.
                                                                                          GlobalReference)),
                                "CreateArray", expression);
                    }
                    else
                    {
                        expressions[i + offset] =
                            new CodeObjectCreateExpression(
                                new CodeTypeReference(typeof (Value), CodeTypeReferenceOptions.GlobalReference),
                                expression);
                    }
                }
                CodeStatement call;
                var env = new CodeVariableReferenceExpression("env");
                var invokeExpression = new CodeMethodInvokeExpression(env, callName.ToString(), expressions);
                if (isConstructor || (returnType != null && returnType.FullName == "void"))
                {
                    call = new CodeExpressionStatement(invokeExpression);
                }
                else
                {
                    if (returnType != null && returnType.isPrimitive())
                    {
                        call = new CodeMethodReturnStatement(invokeExpression);
                    }
                    else
                    {
                        CodeTypeReference reference;
                        reference = generator.ResolveClassReference(returnType);
                        CodeExpression methodInvokeExpression = invokeExpression;
                        if ((returnType != null && returnType.isArray()))
                        {
                            var expression = new CodeMethodInvokeExpression(env, "ConvertArrayToNet",
                                                                            methodInvokeExpression);
                            expression.Method.TypeArguments.Add(new CodeTypeReference(reference.BaseType
                                /*, CodeTypeReferenceOptions.GlobalReference*/));
                            methodInvokeExpression = expression;
                            var castExpression = new CodeCastExpression(reference, methodInvokeExpression);
                            call = new CodeMethodReturnStatement(castExpression);
                        }
                        else
                        {
                            var castExpression =
                                new CodeMethodInvokeExpression(
                                    new CodeMethodReferenceExpression(
                                        new CodeTypeReferenceExpression(new CodeTypeReference(typeof (Bridge),
                                                                                              CodeTypeReferenceOptions.
                                                                                                  GlobalReference)),
                                        "ToCLR", new[] {reference}), methodInvokeExpression);
                            call = new CodeMethodReturnStatement(castExpression);
                        }
                    }
                }
                statements.Add(call);
            }

            private CodeMemberMethod CreateMethodSignature(Class clazz, string name, string signature, Class returnType,
                                                           IList<Class> parameterTypes, ModifierFlags modifiers,
                                                           bool isProxy,
                                                           bool isInterfaceMethod, bool isSealedClass)
            {
                var meth = new CodeMemberMethod();
                meth.Name = name.Replace('$', '_');
                meth.ReturnType = generator.ResolveClassReference(returnType);
                meth.Attributes = 0;
                CreateModifiers(meth, name, returnType, modifiers, clazz, signature, isProxy,
                                isInterfaceMethod, isSealedClass);
                CreateSignatureParams(meth, parameterTypes);

                if (!generator.config.SkipSignatures)
                {
                    var declaration =
                        new CodeAttributeDeclaration(new CodeTypeReference(typeof (JavaMethodAttribute),
                                                                           CodeTypeReferenceOptions.GlobalReference));
                    CodeExpression expression = new CodePrimitiveExpression(signature);
                    declaration.Arguments.Add(new CodeAttributeArgument(expression));
                    meth.CustomAttributes.Add(declaration);
                }

                return meth;
            }

            private void CreateModifiers(CodeMemberMethod meth, string name, Class returnType, ModifierFlags modifiers,
                                         Class clazz, string signature, bool isProxy,
                                         bool isInterfaceMethod, bool isSealedClass)
            {
                JNIEnv env = JNIEnv.GetEnv();
                bool over = false;
                if ((modifiers & ModifierFlags.Static) != ModifierFlags.None)
                {
                    meth.Attributes |= MemberAttributes.Static;
                }
                else if (returnType != null)
                {
                    Class super = clazz.getSuperclass();
                    while (super != null)
                    {
                        if (env.GetMethodIDNoThrow(super, name, signature) != null)
                        {
                            if (clazz.getName() != "java.lang.Throwable")
                            {
                                meth.Attributes |= MemberAttributes.Override;
                            }
                            over = true;
                            break;
                        }

                        string ret = Bridge.JavaSignature(returnType);
                        string parameters = signature.Replace(")" + ret, ")Ljava/lang/Object;");
                        if (env.GetMethodIDNoThrow(super, name, parameters) != null)
                        {
                            meth.Attributes |= MemberAttributes.New;
                            break;
                        }

                        super = super.getSuperclass();
                    }
                }
                //bool pub = false;
                if ((modifiers & ModifierFlags.Public) != ModifierFlags.None)
                {
                    meth.Attributes |= MemberAttributes.Public;
                    //pub = true;
                }
                if ((modifiers & ModifierFlags.Protected) != ModifierFlags.None)
                {
                    meth.Attributes |= MemberAttributes.Family;
                    //pub = true;
                }
                /*if ((modifiers & Modifier.Abstract) != Modifier.None && !over && !isInterfaceMethod)
                {
                    meth.Attributes |= MemberAttributes.Abstract;
                    if (!pub)
                    {
                        meth.Attributes |= MemberAttributes.FamilyAndAssembly;
                    }
                }*/
                if (((modifiers & ModifierFlags.Final) != ModifierFlags.None || isSealedClass) && !over)
                {
                    meth.Attributes |= MemberAttributes.Final;
                }

                if (isProxy)
                {
                    meth.Attributes |= MemberAttributes.Public;
                    meth.Attributes |= MemberAttributes.Final;
                    /*if ((meth.Attributes & MemberAttributes.Abstract) == MemberAttributes.Abstract)
                    {
                        meth.Attributes ^= MemberAttributes.Abstract;
                    }*/
                }
            }

            private CodeTypeReference CreateClassReference(Class clazz, bool isProxy)
            {
                var reference =
                    new CodeTypeReference(clazz.PackageName + "." + (isProxy ? "__" + clazz.ShortName : clazz.ShortName)
                        /*, CodeTypeReferenceOptions.GlobalReference*/);
                return reference;
            }

            private string GetParamName(Class type, int index)
            {
                string name;
                if (type is Class)
                {
                    name = (type as Class).ShortName;
                }
                else
                {
                    name = type.ToString();
                }


                int b = 0;
                for (int i = 0; i < name.Length; i++)
                {
                    if (name[i] >= 'A' && name[i] <= 'Z')
                    {
                        b = i;
                    }
                    if (name[i] == '.')
                    {
                        b = i + 1;
                    }
                }
                var sb = new StringBuilder(name.Substring(b));
                sb.Replace("[", "");
                sb.Replace(";", "");
                sb.Replace("]", "");
                sb.Replace("<", "");
                sb.Replace(">", "");
                sb.Replace("?", "");
                sb.Replace("@", "");
                sb.Replace(".", "");

                sb.Append("Par");
                sb.Append(index);
                sb[0] = Char.ToLower(sb[0]);

                return sb.ToString();
            }
        }

        #endregion
    }
}